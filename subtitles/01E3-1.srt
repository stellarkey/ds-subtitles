1
00:00:00,001 --> 00:00:04,001
学堂在线MOOC开源字幕组：含光

2
00:00:04,611 --> 00:00:09,000
比如说，我们可以按照这样的一个图示来进行改进

3
00:00:09,906 --> 00:00:10,948
具体来说

4
00:00:10,973 --> 00:00:16,823
我们总是把整个这个序列每次都划分为左侧和右侧两部分

5
00:00:17,165 --> 00:00:19,196
这里我不妨把它们垂直地画上

6
00:00:19,585 --> 00:00:21,704
这个无所谓，比如说左侧和右侧

7
00:00:23,546 --> 00:00:24,355
接下来呢

8
00:00:24,561 --> 00:00:27,252
我们递归地求解两个子问题

9
00:00:28,300 --> 00:00:31,990
分别求出左侧的最大元素和次大元素

10
00:00:32,149 --> 00:00:35,339
以及右侧的最大元素和次大元素

11
00:00:36,571 --> 00:00:37,436
接下来呢

12
00:00:37,675 --> 00:00:39,992
全局的最大元必然来自于左侧的最大元和右侧的最大元之间的更大者

13
00:00:37,675 --> 00:00:41,819


14
00:00:40,017 --> 00:00:41,311


15
00:00:45,241 --> 00:00:47,130
为此我们需要花费一次比较

16
00:00:47,955 --> 00:00:49,511
那么当然有两种情况

17
00:00:49,813 --> 00:00:51,749
所以这里呢画出对称的情况

18
00:00:52,464 --> 00:00:55,178
可能确实是左侧这个最大者胜出

19
00:00:55,400 --> 00:00:57,384
也可能是右侧这个最大者胜出

20
00:00:57,828 --> 00:01:00,442
不失一般性，我们先考虑左侧的这个

21
00:01:00,466 --> 00:01:01,614
右侧完全对称的

22
00:01:02,209 --> 00:01:05,447
如果经过一次比较以后我们确认左侧的胜出

23
00:01:05,653 --> 00:01:08,409
那么我们又可以进而得出结论

24
00:01:08,434 --> 00:01:13,739
全局次大元素必然是来自于左侧的次大元，

25
00:01:13,763 --> 00:01:17,513
和这个刚才，如果说是败下来的，右侧的最大元

26
00:01:18,663 --> 00:01:22,917
同样，我们通过一次比较就可以确认他们中间的胜者

27
00:01:23,303 --> 00:01:30,176
大家注意，在这里，
我们刚才失败的那个子问题中的次大者无需参与比较

28
00:01:31,382 --> 00:01:32,430
我们来看一下

29
00:01:32,620 --> 00:01:35,636
这样的思路可以整理为这样一段代码

30
00:01:35,986 --> 00:01:37,763
当然这里也有退化的情况

31
00:01:37,795 --> 00:01:40,683
我们把这样的退化情况的实现和解释

32
00:01:40,708 --> 00:01:41,259
这个任务

33
00:01:41,283 --> 00:01:43,001
留给同学们在课后完成

34
00:01:45,706 --> 00:01:46,595
一般而言

35
00:01:46,753 --> 00:01:49,976
我们都是取lo和hi的中点

36
00:01:52,817 --> 00:01:53,436
并且

37
00:01:53,785 --> 00:01:55,916
递归地求解出刚刚我们所说的

38
00:01:55,941 --> 00:02:00,319
x1L, x2L 以及 x1R, x2R

39
00:02:02,952 --> 00:02:07,487
接下来我们对两个子区间的最大者进行1次比较

40
00:02:07,714 --> 00:02:10,242
就可以确定其中的胜者

41
00:02:10,267 --> 00:02:11,478
也就是全局的最大者

42
00:02:11,693 --> 00:02:13,179
或者是他(x1L)，或者是他(x1R)

43
00:02:15,895 --> 00:02:16,938
那么，刚才我们说了

44
00:02:17,143 --> 00:02:19,886
左边这个图，对应的是if这个情况

45
00:02:20,181 --> 00:02:22,573
右边这个图，对应的是else这个情况

46
00:02:25,384 --> 00:02:29,148
进而，全局的次大元素x2怎么来确定呢

47
00:02:29,998 --> 00:02:30,621
我们可以看到

48
00:02:30,667 --> 00:02:32,050
无论是 <b>if</b> 还是 <b>else</b>

49
00:02:32,130 --> 00:02:32,731
他都是对称的

50
00:02:32,935 --> 00:02:35,463
我们只需要再进行一次比较

51
00:02:38,051 --> 00:02:40,681
这次比较其实对应的就是这个

52
00:02:41,373 --> 00:02:42,303
我们再回顾一下

53
00:02:42,450 --> 00:02:43,607
刚才这是比较

54
00:02:43,698 --> 00:02:45,557
其实对应的是，它

55
00:02:45,750 --> 00:02:46,952
或者是说，它

56
00:02:47,598 --> 00:02:49,208
后面这两次比较

57
00:02:49,333 --> 00:02:50,636
对应的是，它

58
00:02:51,158 --> 00:02:51,940
或者是，它

59
00:02:52,356 --> 00:02:53,297
我们可以看到

60
00:02:53,547 --> 00:02:54,941
无论如何

61
00:02:55,089 --> 00:02:57,413
在每一个递归实例中

62
00:02:57,708 --> 00:02:59,658
即便在最坏的情况

63
00:02:59,726 --> 00:03:02,401
我们至多只需要进行一次

64
00:03:02,425 --> 00:03:03,762
和两次比较

65
00:03:04,490 --> 00:03:05,544
这也是为什么

66
00:03:05,568 --> 00:03:08,254
可以用递推方程的方式写出来

67
00:03:08,640 --> 00:03:13,773
T(n) 应该是等于两倍的 T(n/2) 规模的子问题

68
00:03:13,798 --> 00:03:14,898
也就是 T(n/2)

69
00:03:15,506 --> 00:03:16,481
再加上

70
00:03:16,844 --> 00:03:17,558
刚才的

71
00:03:17,717 --> 00:03:18,759
两次比较

72
00:03:20,097 --> 00:03:21,118
这样一个递推式

73
00:03:21,186 --> 00:03:22,569
用前面类似的方法

74
00:03:22,594 --> 00:03:23,932
我们可以去求解

75
00:03:24,417 --> 00:03:27,467
得到 5n/3 - 2

76
00:03:28,007 --> 00:03:30,716
当然，如果你不知道具体的求解方法的话

77
00:03:30,741 --> 00:03:32,225
你不妨去验证一下

78
00:03:32,281 --> 00:03:34,447
我们说，这种结果是非常好验证的

79
00:03:35,014 --> 00:03:36,261
按照这样的一个公式

80
00:03:36,386 --> 00:03:38,676
可以得出来 T(n/2) 是多少

81
00:03:38,780 --> 00:03:39,686
然后代进去

82
00:03:39,868 --> 00:03:41,433
不难验证这样一个结果

83
00:03:42,306 --> 00:03:44,199
我们这里需要指出的是

84
00:03:44,299 --> 00:03:45,569
确实我们可以看到

85
00:03:45,637 --> 00:03:47,157
如果此前的方法

86
00:03:47,247 --> 00:03:50,354
在最坏情况下所需要的比较次数

87
00:03:50,547 --> 00:03:52,406
就 n 的常系数而言

88
00:03:52,463 --> 00:03:53,393
如果是 2 的话

89
00:03:53,965 --> 00:03:54,634
现在

90
00:03:54,827 --> 00:03:55,383
在这里

91
00:03:55,507 --> 00:03:57,276
降为了 5/3

92
00:03:58,058 --> 00:03:58,795
我们可以看到

93
00:03:58,943 --> 00:04:00,689
他有一个确定的下降

94
00:04:01,258 --> 00:04:02,868
这种下降
再强调一下

95
00:04:03,073 --> 00:04:05,329
是即便在最坏情况下

96
00:04:05,353 --> 00:04:06,565
也能够保证的

97
00:04:07,808 --> 00:04:09,237
当然，在最好情况下

98
00:04:09,261 --> 00:04:10,065
能够多少

99
00:04:10,757 --> 00:04:11,948
我们也把这个问题

100
00:04:12,129 --> 00:04:14,147
留给大家在课后思考

101
00:04:25,395 --> 00:04:26,348
所以概括一下

102
00:04:26,427 --> 00:04:28,569
我们这一节的主要内容是

103
00:04:29,021 --> 00:04:31,526
教给了大家迭代和递归的算法

104
00:04:35,114 --> 00:04:38,107
包括两种重要的算法的策略

105
00:04:38,487 --> 00:04:40,312
减而治之和分而治之

106
00:04:41,211 --> 00:04:42,107
更重要的是

107
00:04:42,131 --> 00:04:44,409
结合这两种策略的介绍和实例

108
00:04:44,830 --> 00:04:45,691
我们给出了

109
00:04:45,717 --> 00:04:49,263
递归算法的两种典型的常用的分析方法

110
00:04:50,312 --> 00:04:52,534
也就是递归跟踪和递推式

111
00:04:53,407 --> 00:04:54,121
在后边

112
00:04:54,348 --> 00:04:55,470
我们将会看到

113
00:04:55,494 --> 00:04:57,080
更多更复杂的

114
00:04:57,104 --> 00:04:58,294
这方面的例子

